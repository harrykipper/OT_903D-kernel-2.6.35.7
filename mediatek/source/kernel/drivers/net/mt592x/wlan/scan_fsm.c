






#include "precomp.h"




#if DBG
/*lint -save -e64 Type mismatch */
static PUINT_8 apucDebugScanState[SCAN_STATE_NUM] = {
    DISP_STRING("SCAN_STATE_IDLE"),
    DISP_STRING("SCAN_STATE_ACTIVE"),
};
/*lint -restore */
#endif /* DBG */




/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
VOID
scanFsmInit (
    P_ADAPTER_T prAdapter
    )
{
    P_SCAN_INFO_T prScanInfo;
    P_SCAN_CONFIG_T prScanConfig;


    ASSERT(prAdapter);

    prScanInfo = &prAdapter->rScanInfo;
    prScanConfig = &prScanInfo->rScanConfig;

    prScanInfo->eCurrentState = SCAN_STATE_IDLE;

    ARB_INIT_TIMER(prAdapter,
                   prScanInfo->rScanCheckForHangTimer,
                   arbFsmRunEventScanCheckForHangTimeOut,
                   TRUE);

    ARB_INIT_TIMER(prAdapter,
                   prScanInfo->rPartialScanTimer,
                   arbFsmRunEventScanPartialScanTimeOut,
                   TRUE);


    /* Initial the scan config */
    prScanConfig->eScanType                     = DEFAULT_SCAN_TYPE;
    prScanConfig->ucChnlDwellTimeMin            = DEFAULT_SCAN_PER_CHNL_MIN_DWELL_TIME;
    prScanConfig->ucChnlDwellTimeExt            = DEFAULT_SCAN_PER_CHNL_EXT_DWELL_TIME;
    prScanConfig->u2RxFifoThreshold             = DEFAULT_SCAN_RX_FIFO_THRESHOLD;
    prScanConfig->ucNumOfPrbReq                 = DEFAULT_SCAN_NUM_OF_PROBE_REQUEST;
    prScanConfig->ucNumOfSpecifiedSsidPrbReq    = DEFAULT_SCAN_NUM_OF_SPECIFIED_PROBE_REQ;
    prScanConfig->fgToHonorServicePeriod        = DEFAULT_SCAN_HONOR_SERVICE_PERIOD;
    prScanConfig->fgToEnableTriggerEvent        = DEFAULT_SCAN_ENABLE_TRIGGER_EVENT;

    prScanConfig->rBgScanCfg.u2BaseWakePeriod   = BG_SSID_SCAN_BASE_WAKEUP_PERIOD;
    prScanConfig->rBgScanCfg.ucBgScanStepOfWakePeriod = BG_SSID_SCAN_WAKEUP_PERIOD_STEPS;
    prScanConfig->rBgScanCfg.ucBgScanMinRcpiThr = BG_SSID_SCAN_WAKEUP_MIN_RCPI;

    prScanInfo->fgIsScanReqProceeding           = FALSE;

    return;
}


/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
__KAL_INLINE__ VOID
scanFsmTransAction_IDLE_to_ACTIVE (
    IN P_ADAPTER_T prAdapter
    )
{
    P_SCAN_INFO_T prScanInfo;
    P_SCAN_CONFIG_T prScanCfg;
    UINT_32 rStatus = WLAN_STATUS_SUCCESS;
#if CFG_SUPPORT_802_11D
    P_CONNECTION_SETTINGS_T prConnSettings;
#endif

    ASSERT(prAdapter);

#if CFG_SUPPORT_802_11D
    prConnSettings = &prAdapter->rConnSettings;
#endif

    prScanInfo = &prAdapter->rScanInfo;
    prScanCfg = &prScanInfo->rScanConfig;

    /* For the state transition from BG SSID scan to SCAN, scan done interrupt
       will be generated from the exit of BG SSID scan (LP own back).
       So clearing the scan done interrupt status is to prevent the confusion
       whether the scan done is generated by SCAN or BG SSID scan.
    */
    NIC_RESET_INT_EVENT(prAdapter, INT_EVENT_SCAN_DONE);

#if CFG_WORKAROUND_HEC_5269
    /* Unset TX_DONE event */
    NIC_UNSET_INT_EVENT(prAdapter, INT_EVENT_TX);
#endif

    if (prScanCfg->ucNumOfPrbReq == 0) {
        if (prScanCfg->eScanType == SCAN_TYPE_ACTIVE_SCAN) {
            prScanCfg->eScanType = SCAN_TYPE_PASSIVE_SCAN;
            ASSERT(0);
        }
    }

#if CFG_SUPPORT_802_11D
    /*   Force to use Passive Scan if multi-domain function is enabled and
     * domain information is not available.
     *   Only one scan dwell time is applied, which is combined min. and max.
     * scan dwell time.
     */
    if (prConnSettings->fgMultiDomainCapabilityEnabled) {
        if (prAdapter->eConnectionState == MEDIA_STATE_DISCONNECTED) {
            prScanCfg->eScanType = SCAN_TYPE_PASSIVE_SCAN;
            prScanCfg->ucChnlDwellTimeMin += prScanCfg->ucChnlDwellTimeExt;
            prScanCfg->ucChnlDwellTimeExt = 0;
        } else {
            P_BSS_INFO_T prBssInfo = &prAdapter->rBssInfo;
            if (!prBssInfo->fgIsCountryInfoPresent) {
                prScanCfg->eScanType = SCAN_TYPE_PASSIVE_SCAN;
                prScanCfg->ucChnlDwellTimeMin += prScanCfg->ucChnlDwellTimeExt;
                prScanCfg->ucChnlDwellTimeExt = 0;
            }
        }
    }
#endif

    /* Submit probe request frame(s) if Active Scan is applied */
    if (prScanCfg->eScanType == SCAN_TYPE_ACTIVE_SCAN) {
        if ((rStatus = scanSendProbeReqFrames(prAdapter,
                                   prScanCfg->rSpecifiedSsid.aucSsid,
                                   prScanCfg->rSpecifiedSsid.u4SsidLen,
                                   prScanCfg->ucNumOfPrbReq,
                                   prScanCfg->ucNumOfSpecifiedSsidPrbReq)) != WLAN_STATUS_PENDING) {

            if(rStatus != WLAN_STATUS_SUCCESS) {
            ASSERT(0);
            }
            //error handling ?

            return;
        }
    }

    /* Configure HW scan parameters, which is through share memory input */
    nicHwScanConfig(prAdapter, prScanCfg, prScanInfo->eCurrentHwScanMode);

    /* Disable beacon timeout counter during scan */
    nicpmDisableTimeoutCounter(prAdapter);

    /* Set RX filter to receive beacon from different BSSID */
    NIC_SET_RX_FILTER(prAdapter, RXFILTER_RXDIFFBSSIDBCN);

    /* Set RX filter to receive probe response from different BSSID */
    NIC_SET_RX_FILTER(prAdapter, RXFILTER_RXDIFFBSSIDPRORESP);


    /* Enable HW scan */
    nicHwScanEnable(prAdapter, prScanInfo->eCurrentHwScanMode);

    return;
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
__KAL_INLINE__ VOID
scanFsmTransAction_ACTIVE_to_IDLE_DONE (
    IN P_ADAPTER_T prAdapter
    )
{
    /* This is to workaround CR1097.
     * Driver will always disable scan function for preventing SW/ HW state
     * un-synchronized issue.
     */
    P_SCAN_INFO_T prScanInfo;

    ASSERT(prAdapter);

    prScanInfo = &prAdapter->rScanInfo;

    nicHwScanDisable(
        prAdapter,
        prScanInfo->eCurrentHwScanMode);

    return;
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
__KAL_INLINE__ VOID
scanFsmTransAction_ACTIVE_to_IDLE_ABORT (
    IN P_ADAPTER_T prAdapter
    )
{
    P_SCAN_INFO_T prScanInfo;

    ASSERT(prAdapter);

    prScanInfo = &prAdapter->rScanInfo;

    nicHwScanDisable(
        prAdapter,
        prScanInfo->eCurrentHwScanMode);

    return;
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
VOID
scanFsmStep (
    IN P_ADAPTER_T          prAdapter,
    IN ENUM_SCAN_STATE_T    eNextState
    )
{
    P_SCAN_INFO_T prScanInfo;
    P_SCAN_STATUS_T prScanStatus;

    DEBUGFUNC("scanFsmStep");

    ASSERT(prAdapter);

    prScanInfo = &prAdapter->rScanInfo;
    prScanStatus = &prScanInfo->rScanStatus;


    DBGLOG(SCAN, STATE, ("TRANSITION: [%s] -> [%s]\n",
                         apucDebugScanState[prScanInfo->eCurrentState],
                         apucDebugScanState[eNextState]));

    prScanInfo->eCurrentState = eNextState;

    /* Do tasks of the State that we just entered */
    switch (prScanInfo->eCurrentState) {
    case SCAN_STATE_IDLE:
        /* Enable beacon timeout counter, which is disabled during scan */
        nicpmEnableTimeoutCounter(prAdapter);

        /* Set RX filter for not to receive beacon from different BSSID */
        NIC_UNSET_RX_FILTER(prAdapter, RXFILTER_RXDIFFBSSIDBCN);

        /* Set RX filter for not to receive probe response from different BSSID */
        NIC_UNSET_RX_FILTER(prAdapter, RXFILTER_RXDIFFBSSIDPRORESP);

#if CFG_WORKAROUND_HEC_5269
        /* Flush AC4 before set TX_DONE event */
        nicTxFlushStopQueues(prAdapter, TXQ_MGMT_MASK, 0x0 /*(UINT_8)NULL*/);

        /* Set TX_DONE event */
        NIC_SET_INT_EVENT(prAdapter, INT_EVENT_TX);
#endif

        nicHwScanConfigRestore(prAdapter,
                               &prScanInfo->rScanConfig,
                               prScanInfo->eCurrentHwScanMode);

        if (prScanInfo->eCurrentHwScanMode == ENUM_HW_SCAN_NORMAL_SCAN) {
            DBGLOG(SCAN, INFO, (">>ucLastScanChnlIdx = %d,  ucLastScanBandIdx = %d.\n",
                prScanStatus->ucLastScanChnlIdx, prScanStatus->ucLastScanBandIdx));

            nicHwScanGetLastScannedChnlFreq(
                prAdapter,
                &prScanStatus->ucLastScanChnlIdx,
                &prScanStatus->ucLastScanBandIdx);

            DBGLOG(SCAN, INFO, ("<<ucLastScanChnlIdx = %d,  ucLastScanBandIdx = %d.\n",
                prScanStatus->ucLastScanChnlIdx, prScanStatus->ucLastScanBandIdx));

            DBGLOG(SCAN, INFO, ("ucNumOfScanChnl = %d\n", prScanInfo->rScanConfig.ucNumOfScanChnl));
        }
        break;

    case SCAN_STATE_ACTIVE:
        break;

    default:
        ASSERT(0); /* Make sure we have handle all STATEs */
    }

    return;

}


/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
WLAN_STATUS
scanFsmRunEventScanReqSetup (
    IN P_ADAPTER_T prAdapter,
    IN P_SCAN_REQ_CONFIG_T prScanReqConfig
    )
{
    P_SCAN_INFO_T prScanInfo;
    P_SCAN_CONFIG_T prScanCfg;

    DEBUGFUNC("scanFsmRunEventScanReqSetup");

    ASSERT(prAdapter);

    prScanInfo = &prAdapter->rScanInfo;
    prScanCfg = &prScanInfo->rScanConfig;

    // New SCAN Request.
    if (prScanReqConfig) {

        // Previous SCAN is finished.
        if (!prScanInfo->fgIsScanReqProceeding) {

            //4 <1> Setup the SCAN Config - Basic Parameters
            /* Update SCAN Type */
            prScanCfg->eScanType = prScanReqConfig->eScanType;

            /* Update SCAN Channel List */
            DBGLOG(SCAN, TRACE, ("prScanReqConfig->ucNumOfScanChnl = %d\n",
                prScanReqConfig->ucNumOfScanChnl));

            kalMemCopy(&prScanCfg->arChnlInfoList[0],
                       &prScanReqConfig->arChnlInfoList[0],
                       prScanReqConfig->ucNumOfScanChnl * sizeof(RF_CHANNEL_INFO_T));

#if DBG
            {
                UINT_32 i;

                for (i = 0; i < prScanReqConfig->ucNumOfScanChnl; i++) {
                    DBGLOG(SCAN, TRACE, ("prScanCfg->arChnlInfoList[%ld].ucChannelNum = %d, eBand = %d\n",
                        i, prScanCfg->arChnlInfoList[i].ucChannelNum, prScanCfg->arChnlInfoList[i].eBand));
                }
            }
#endif /* DBG */

            /* Update total SCAN Channel number */
            prScanCfg->ucTotalScanChannelCount = prScanReqConfig->ucNumOfScanChnl;
            prScanCfg->ucFinishedChannelCount = 0;

            /* Update MinChannelTime
             *        ExtChannelTime = (MaxChannelTime - MinChannelTime) in TU.
             */
            prScanCfg->ucChnlDwellTimeMin = prScanReqConfig->ucChnlDwellTimeMin;
            prScanCfg->ucChnlDwellTimeExt = prScanReqConfig->ucChnlDwellTimeExt;

            DBGLOG(SCAN, TRACE, ("prScanCfg->u2ChnlDwellTimeMin = %d, prScanCfg->u2ChnlDwellTimeExt = %d\n",
                prScanCfg->ucChnlDwellTimeMin, prScanCfg->ucChnlDwellTimeExt));

            prScanCfg->rSpecifiedSsid = prScanReqConfig->rSpecifiedSsid;

            /* Specify number of ProbeReq for Active SCAN */
            prScanCfg->ucNumOfPrbReq = prScanReqConfig->ucNumOfPrbReq;
            prScanCfg->ucNumOfSpecifiedSsidPrbReq = prScanReqConfig->ucNumOfSpecifiedSsidPrbReq;

            /* Update SCAN DONE call back handler */
            prScanCfg->pfScanDoneHandler = prScanReqConfig->pfScanDoneHandler;


            //4 <2> Setup the SCAN Config - Advanced Parameters
            /* Update SCAN Method */
            prScanCfg->eScanMethod = prScanReqConfig->eScanMethod;
            if (prScanReqConfig->eScanMethod == SCAN_METHOD_FULL_SCAN) {
                /* Update SCAN Priority */
                prScanCfg->fgToHonorServicePeriod = FALSE;
                prScanCfg->fgToEnableTriggerEvent = FALSE;

                /* Try to scan all channel in a request */
                prScanCfg->ucNumOfScanChnl = prScanCfg->ucTotalScanChannelCount;
                prScanCfg->ucNumOfPassiveScanInVoIP = 0;
            }
            else if (prScanReqConfig->eScanMethod == SCAN_METHOD_ONLINE_SCAN) {
                /* Update SCAN Priority */
                prScanCfg->fgToHonorServicePeriod = TRUE;
                prScanCfg->fgToEnableTriggerEvent = TRUE;

                /* Try to scan all channel in a request */
                prScanCfg->ucNumOfScanChnl = prScanCfg->ucTotalScanChannelCount;
                prScanCfg->ucNumOfPassiveScanInVoIP = 0;
            }
            else if (prScanReqConfig->eScanMethod == SCAN_METHOD_VOIP_ONLINE_SCAN) {
                /* Update SCAN Priority */
                prScanCfg->fgToHonorServicePeriod = TRUE;
                prScanCfg->fgToEnableTriggerEvent = TRUE;

                /* Try to scan 1 channel in a request */
                prScanCfg->ucNumOfScanChnl = 1;
                prScanCfg->ucNumOfPassiveScanInVoIP = SCAN_VOIP_PASSIVE_SCAN_INTERVAL;
            }
            else {
                ASSERT(0);
            }

            /* Update RX Fifo Threshold */
            prScanCfg->u2RxFifoThreshold = 0;


            //4 <3> Clear previous SCAN status
            prScanInfo->rScanStatus.ucLastScanChnlIdx = 0;
            prScanInfo->rScanStatus.ucLastScanBandIdx = 0;


            //4 <4> Update SCAN proceeding flag
            prScanInfo->fgIsScanReqProceeding = TRUE;

        }
        else {
            return WLAN_STATUS_FAILURE; /* Previous SCAN was not finished yet */
        }
    }
    else {
        if (!prScanInfo->fgIsScanReqProceeding) {
            ASSERT(0);
            return WLAN_STATUS_FAILURE; /* We didn't have proper SCAN Config for PARTIAL SCAN. */
        }
    }

    ASSERT(prScanInfo->fgIsScanReqProceeding);

    return WLAN_STATUS_SUCCESS;

}


/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
VOID
scanFsmRunEventScanReqCleanUp (
    IN P_ADAPTER_T prAdapter
    )
{
    P_SCAN_INFO_T prScanInfo;
    P_SCAN_CONFIG_T prScanCfg;

    DEBUGFUNC("scanFsmRunEventScanReqCleanUp");

    ASSERT(prAdapter);
    prScanInfo = &prAdapter->rScanInfo;
    prScanCfg = &prScanInfo->rScanConfig;

    /* We should call Scan Abort before doing "Request Clean Up" */
    if (prScanInfo->fgIsScanReqProceeding) {
        ASSERT(prScanInfo->eCurrentState == SCAN_STATE_IDLE);

        if (prScanCfg->eScanMethod == SCAN_METHOD_ONLINE_SCAN) {
            ARB_CANCEL_TIMER(prAdapter, prScanInfo->rPartialScanTimer);
        }
        else if (prScanCfg->eScanMethod == SCAN_METHOD_VOIP_ONLINE_SCAN) {

            DBGLOG(SCAN, INFO, ("Disable traps for PS VOIP SCAN\n"));

            NIC_TX_UNSET_VOIP_SCAN_TRIGGER_EVENT(prAdapter);
        }

        prScanInfo->fgIsScanReqProceeding = FALSE;
    }

    return;
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
WLAN_STATUS
scanFsmRunEventStart (
    IN P_ADAPTER_T  prAdapter,
    IN ENUM_HW_SCAN_MODE_T eHwScanMode
    )
{
    P_SCAN_CONFIG_T prScanCfg;
    P_SCAN_INFO_T prScanInfo;
    ENUM_SCAN_STATE_T eNextState;
    WLAN_STATUS rStatus = WLAN_STATUS_SUCCESS;

    DEBUGFUNC("scanFsmRunEventStart");
    DBGLOG(SCAN, INFO, ("scanFsmRunEventStart\n"));

    ASSERT(prAdapter);

    prScanInfo = &prAdapter->rScanInfo;
    prScanCfg = &prScanInfo->rScanConfig;
    eNextState = prScanInfo->eCurrentState;


    if (prScanInfo->eCurrentState != SCAN_STATE_ACTIVE) {
        prScanInfo->eCurrentHwScanMode = eHwScanMode;

        SCAN_STATE_TRANSITION(prAdapter, IDLE, ACTIVE);

        if (eHwScanMode == ENUM_HW_SCAN_NORMAL_SCAN) {
            /* Set the timeout function with additional 1 second guard for service period */
            ARB_SET_TIMER(prAdapter,
                          prScanInfo->rScanCheckForHangTimer,
                          (SCAN_CHECK_FOR_HANG_GUARD_TIME_MSEC +
                           (prScanCfg->ucNumOfScanChnl *
                            (prScanCfg->ucChnlDwellTimeMin + prScanCfg->ucChnlDwellTimeExt))) );
        }
    }

    return rStatus;
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
WLAN_STATUS
scanFsmRunEventScanDone (
    IN P_ADAPTER_T  prAdapter
    )
{
    P_SCAN_INFO_T prScanInfo;
    ENUM_SCAN_STATE_T eNextState;
    WLAN_STATUS rStatus = WLAN_STATUS_SUCCESS;

    DEBUGFUNC("scanFsmRunEventScanDone");
    DBGLOG(SCAN, INFO, ("scanFsmRunEventScanDone\n"));

    ASSERT(prAdapter);

    prScanInfo = &prAdapter->rScanInfo;
    eNextState = prScanInfo->eCurrentState;

    if (prScanInfo->eCurrentState != SCAN_STATE_IDLE) {
        //4 <1> Make state transition to SCAN_STATE_IDLE
        SCAN_STATE_TRANSITION1(prAdapter, ACTIVE, IDLE, DONE);

        //4 <2> Check SCAN Status for issuing Next Partial SCAN or completing the whole SCAN sequence.
        if (prScanInfo->eCurrentHwScanMode == ENUM_HW_SCAN_NORMAL_SCAN) {
            //4 <3> Cancel SCAN Timeout Timer.
            ARB_CANCEL_TIMER(prAdapter, prScanInfo->rScanCheckForHangTimer);

            scanCheckScanStatus(prAdapter);
        }
    }

    return rStatus;
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
WLAN_STATUS
scanFsmRunEventScanAbort (
    IN P_ADAPTER_T  prAdapter
    )
{
    P_SCAN_INFO_T prScanInfo;
    ENUM_SCAN_STATE_T eNextState;
    WLAN_STATUS rStatus = WLAN_STATUS_SUCCESS;

    DEBUGFUNC("scanFsmRunEventScanAbort");
    DBGLOG(SCAN, INFO, ("scanFsmRunEventScanAbort\n"));

    ASSERT(prAdapter);

    prScanInfo = &prAdapter->rScanInfo;
    eNextState = prScanInfo->eCurrentState;

    if (prScanInfo->eCurrentState != SCAN_STATE_IDLE) {
        //4 <1> Make state transition to SCAN_STATE_IDLE
        SCAN_STATE_TRANSITION1(prAdapter, ACTIVE, IDLE, ABORT);

        //4 <2> Cancel SCAN Timeout Timer.
        ARB_CANCEL_TIMER(prAdapter, prScanInfo->rScanCheckForHangTimer);

        //4 <3> Do call back function.
        if (prScanInfo->rScanConfig.pfScanDoneHandler) {
            prScanInfo->rScanConfig.pfScanDoneHandler(prAdapter, WLAN_STATUS_FAILURE);
        }

#if CFG_WORKAROUND_HEC_5512
        //4 <4> Recover from aborting from BG SSID scan state
        if (prScanInfo->eCurrentHwScanMode == ENUM_HW_SCAN_BG_SSID_SCAN) {
#if 0
            DBGLOG(SCAN, INFO, ("Recover from aborting from BG SSID scan state\n"));

            nicTxFlushStopQueues(prAdapter, TXQ_MGMT_MASK, 0x0 /*(UINT_8)NULL*/);

            nicTxStartQueues(prAdapter, TXQ_MGMT_MASK);

            scanSendProbeReqFrames(prAdapter,
                                   NULL,
                                   0,
                                   1,
                                   0,
                                   FALSE);

            kalMdelay(10);
#else
            nicLogicReset(prAdapter);
#endif
        }
#endif
    }

    NIC_RESET_INT_EVENT(prAdapter, INT_EVENT_SCAN_DONE);

    return rStatus;
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
WLAN_STATUS
scanFsmRunEventScanStop (
    IN P_ADAPTER_T  prAdapter
    )
{
    P_SCAN_INFO_T prScanInfo;
    ENUM_SCAN_STATE_T eNextState;
    WLAN_STATUS rStatus = WLAN_STATUS_SUCCESS;

    DEBUGFUNC("scanFsmRunEventScanStop");

    ASSERT(prAdapter);

    DBGLOG(SCAN, INFO, ("scanFsmRunEventScanStop\n"));

    prScanInfo = &prAdapter->rScanInfo;
    eNextState = prScanInfo->eCurrentState;

    if (prScanInfo->eCurrentState != SCAN_STATE_IDLE) {
        //4 <1> Make state transition to SCAN_STATE_IDLE
        SCAN_STATE_TRANSITION1(prAdapter, ACTIVE, IDLE, ABORT);

        //4 <2> Cancel SCAN Timeout Timer.
        ARB_CANCEL_TIMER(prAdapter, prScanInfo->rScanCheckForHangTimer);

        //4 <3> Check SCAN Status for issuing Next Partial SCAN or completing the whole SCAN sequence.
        if (prScanInfo->eCurrentHwScanMode == ENUM_HW_SCAN_NORMAL_SCAN) {
            scanCheckScanStatus(prAdapter);
        }

#if CFG_WORKAROUND_HEC_5512
        //4 <4> Recover from aborting from BG SSID scan state
        if (prScanInfo->eCurrentHwScanMode == ENUM_HW_SCAN_BG_SSID_SCAN) {
#if 0
            DBGLOG(SCAN, INFO, ("Recover from stopping from BG SSID scan state\n"));

            nicTxFlushStopQueues(prAdapter, TXQ_MGMT_MASK, 0x0 /*(UINT_8)NULL*/);

            nicTxStartQueues(prAdapter, TXQ_MGMT_MASK);

            scanSendProbeReqFrames(prAdapter,
                                   NULL,
                                   0,
                                   1,
                                   0,
                                   FALSE);
            kalMdelay(10);
#else
            nicLogicReset(prAdapter);
#endif
        }
#endif
    }

    return rStatus;
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
VOID
scanCheckScanStatus (
    IN P_ADAPTER_T prAdapter
    )
{
    P_SCAN_INFO_T prScanInfo;
    P_SCAN_CONFIG_T prScanCfg;
    P_SCAN_STATUS_T prScanStatus;

    DEBUGFUNC("scanCheckScanStatus");

    ASSERT(prAdapter);

    prScanInfo = &prAdapter->rScanInfo;
    prScanCfg = &prScanInfo->rScanConfig;
    prScanStatus = &prScanInfo->rScanStatus;

    //4 <1> Check if the SCAN Channel Number is valid.
    ASSERT(prScanCfg->ucNumOfScanChnl);

    //4 <2> Check if the SCAN Status is valid.
    if (prScanStatus->ucLastScanChnlIdx > prScanCfg->ucNumOfScanChnl) {
    /* NOTE(Kevin):
     * For MPW, if we encounter such case, which means the ucLastScanChnlIdx
     * didn't be cleared off while enabling HW SCAN.(has been identified and do bug fixed)
     * For HW version after MPW, this is normal case which means the HW SCAN have
     * finished.
     */
#if DBG & 0 /* According above two reasons, we don't do ASSERT() anymore */
        DBGLOG(SCAN, ERROR, ("ucLastScanChnlIdx: %d > ucNumOfScanChnl: %d\n",
            prScanStatus->ucLastScanChnlIdx,
            prScanCfg->ucNumOfScanChnl));
        ASSERT(0);
#endif /* DBG */

        prScanStatus->ucLastScanChnlIdx = prScanCfg->ucNumOfScanChnl;
    }

//#if DBG
    if (prScanStatus->ucLastScanChnlIdx == 0) {
        DBGLOG(SCAN, WARN, ("Didn't SCAN, ucLastScanChnlIdx == 0.\n"));

        /* NOTE:
           Workaround for the case that the scan is continuously blocked in scan initial phase,
           which may be blocked by polling for unlimited RX packet (more data always asserted).
           This may be happened when testing WPA2 5.2.2.4.

           In this workaround, it will repeat for the same procedure for at most 2 times.
        */
        if (prScanInfo->ucScanBlockInInitialPhaseCount++ == 2) {
            prScanStatus->ucLastScanChnlIdx = 1;
        }
    } else {
        prScanInfo->ucScanBlockInInitialPhaseCount = 0;
    }
//#endif /* DBG */

    //4 <3> Update the Finished Channel Count if necessary.
    if (!prScanCfg->ucNumOfPassiveScanInVoIP) {
        prScanCfg->ucFinishedChannelCount +=
            prScanStatus->ucLastScanChnlIdx;
    }

    //4 <4> Check if SCAN is completed.
    if (prScanCfg->ucFinishedChannelCount > prScanCfg->ucTotalScanChannelCount) {
#if DBG
        DBGLOG(SCAN, ERROR, ("ucFinishedChannelCount: %d > ucTotalScanChannelCount: %d\n",
            prScanCfg->ucFinishedChannelCount,
            prScanCfg->ucTotalScanChannelCount));
        ASSERT(0);
#endif /* DBG */
        prScanCfg->ucFinishedChannelCount = prScanCfg->ucTotalScanChannelCount;
    }


    if (prScanCfg->ucFinishedChannelCount == prScanCfg->ucTotalScanChannelCount &&
        prScanCfg->ucNumOfPassiveScanInVoIP == 0) {

        //4 <4.1> Call the CALL_BACK_FUNC to indicate SCAN was completed.
        if (prScanCfg->pfScanDoneHandler) {
            prScanCfg->pfScanDoneHandler(prAdapter, WLAN_STATUS_SUCCESS);
        }

        prScanCfg->ucTotalScanChannelCount = 0;
        prScanCfg->ucFinishedChannelCount = 0;
        prScanCfg->ucNumOfPassiveScanInVoIP = 0;

        prScanInfo->fgIsScanReqProceeding = FALSE;

        /* GeorgeKuo: */
        DBGLOG(SCAN, INFO, ("Indicate SCAN COMPLETE in scanCheckScanStatus()\n"));
        kalIndicateStatusAndComplete(prAdapter->prGlueInfo,
            WLAN_STATUS_SCAN_COMPLETE,
            NULL,
            0);
    }
    else { /* SCAN is not completed. */

        //4 <4.2> Check follow-up action of each SCAN Method.
        if (prScanCfg->eScanMethod == SCAN_METHOD_FULL_SCAN) {
#if DBG
            DBGLOG(SCAN, ERROR, ("Finished %d < Total %d\n", prScanCfg->ucFinishedChannelCount,
                prScanCfg->ucTotalScanChannelCount));
            ASSERT(0);
#endif /* DBG */
        }
        else if (prScanCfg->eScanMethod == SCAN_METHOD_ONLINE_SCAN) {

            /* Update the Number of Scan Channel */
            prScanCfg->ucNumOfScanChnl = prScanCfg->ucTotalScanChannelCount -
                                               prScanCfg->ucFinishedChannelCount;

            DBGLOG(SCAN, INFO, ("Schedule Next Partial Scan: Left Channel Number = %d, Total = %d\n",
                prScanCfg->ucNumOfScanChnl, prScanCfg->ucTotalScanChannelCount));

            /* Shift the Channel List */
            if (prScanStatus->ucLastScanChnlIdx) {
                if (prScanStatus->ucLastScanChnlIdx < MAXIMUM_OPERATION_CHANNEL_LIST) {
                    kalMemCopy(&prScanCfg->arChnlInfoList[0],
                               &prScanCfg->arChnlInfoList[prScanStatus->ucLastScanChnlIdx],
                               prScanCfg->ucNumOfScanChnl * sizeof(RF_CHANNEL_INFO_T));
                }
                else {
                    DBGLOG(SCAN, ERROR, ("Abnormal last scan channel index %d (> %d)\n",
                        prScanStatus->ucLastScanChnlIdx,
                        MAXIMUM_OPERATION_CHANNEL_LIST));
                    ASSERT(0);
                }
            }

            ARB_SET_TIMER(prAdapter,
                          prScanInfo->rPartialScanTimer,
                          PARTIAL_SCAN_TIMEOUT_MSEC);


        }
        else if (prScanCfg->eScanMethod == SCAN_METHOD_VOIP_ONLINE_SCAN) {

            /* Update the Number of Scan Channel */
            prScanCfg->ucNumOfScanChnl = 1;

            /* Shift the Channel List */
            if (prScanStatus->ucLastScanChnlIdx) {
                if (prScanCfg->ucNumOfPassiveScanInVoIP == 0) {

                    prScanCfg->eScanType = SCAN_TYPE_ACTIVE_SCAN;

                    prScanCfg->arChnlInfoList[0] = prScanCfg->arChnlInfoList[prScanCfg->ucFinishedChannelCount];

                    DBGLOG(SCAN, TRACE, ("Scan Next Channel = %d)\n",
                        prScanCfg->arChnlInfoList[0].ucChannelNum));

                    prScanCfg->ucNumOfPassiveScanInVoIP = SCAN_VOIP_PASSIVE_SCAN_INTERVAL;
                }
                else {
                    prScanCfg->eScanType = SCAN_TYPE_PASSIVE_SCAN;

                    DBGLOG(SCAN, TRACE, ("Passive Scan - Channel = %d)\n",
                        prScanCfg->arChnlInfoList[0].ucChannelNum));

                    if (prScanCfg->ucNumOfPassiveScanInVoIP == 2) {
                        prScanCfg->eScanType = SCAN_TYPE_ACTIVE_SCAN;
                    }

                    prScanCfg->ucNumOfPassiveScanInVoIP--;
                }
            }
            else {
                DBGLOG(SCAN, TRACE, ("Try Scan Again - Channel = %d)\n",
                    prScanCfg->arChnlInfoList[0].ucChannelNum));
            }

            NIC_TX_SET_VOIP_SCAN_TRIGGER_EVENT(prAdapter);

        }
    }

    return;
}


/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
VOID
scanSetupOriginalChannel (
    IN P_ADAPTER_T prAdapter,
    IN UINT_8      ucChannelNum,
    IN ENUM_BAND_T eBand
    )
{
    P_SCAN_INFO_T prScanInfo;
    P_SCAN_CONFIG_T prScanCfg;

    ASSERT(prAdapter);

    prScanInfo = &prAdapter->rScanInfo;
    prScanCfg = &prScanInfo->rScanConfig;


    prScanCfg->rOrgChnlInfo.ucChannelNum = ucChannelNum;
    prScanCfg->rOrgChnlInfo.eBand = eBand;

    return;
}

